## jQuery UI {#jquery-ui}

jQuery UI представляет из себя набор виджетов и плагинов от самих разработчиков jQuery. По моему мнению, данный инструмент необходимо изучить настолько, насколько это требуется, чтобы не писать свои «велосипеды». Скачать-почитать о данной надстройке над jQuery можно на домашней страницы проекта – [http://jqueryui.com/](http://jqueryui.com/).

Что нам необходимо знать о виджетах и плагинах? Первое – это какие они есть, и второе – как работают. На этих двух моментах я и постараюсь остановиться.

### Интерактивность

Начну с полезных плагинов, которые могут упростить жизнь при создании интерактивных интерфейсов:
* [Draggable](http://jqueryui.com/draggable/) – данный компонент позволяет сделать любой DOM-элемент перетаскиваемым при помощи мыши
* [Droppable](http://jqueryui.com/droppable/) – это логичное продолжение компонента Draggable; необходим для работы с контейнерами, внутрь которых можно перетаскивать элементы
* [Resizable](http://jqueryui.com/resizable/) – как следует из названия, даёт возможность растягивать любые DOM-элементы
* [Selectable](http://jqueryui.com/selectable/) – позволяет организовать «выбор» элементов; удобно использовать для организации менеджмента картинок
* [Sortable](http://jqueryui.com/sortable/) – сортировка DOM-элементов

### Виджеты

Виджеты – это уже комплексное решение, содержащее не только код JavaScript, но и некую реализацию HTML и CSS:
*   Accordion – данный виджет следует использовать, если у вас в проекте уже используется jQuery UI; сам по себе основной его функционал можно реализовать в несколько строк (посмотреть можно в [accordion.html](http://anton.shevchuk.name/book/code/accordion.html))
  ![jQuery UI Accordion](/assets/accordion.png)
*   Autocomplete – как и следует из названиz, данный виджет отвечает за добавление функции автодополнения к полям ввода, естественно, с поддержкой AJAX
*   Button – создание кнопок с помощью JavaScript – ещё тот моветон, но, возможно, пригодится, если вы сильно завязались на jQuery UI:
  ![jQuery UI Buttons](/assets/buttons.png)
*   Datepicker – если ваш браузер не поддерживает в полной мере спецификацию HTML 5 и `<input type="date"/>` в частности, то потребуется эмуляция данной возможности с помощью этого виджета:
  ![jQuery UI Datepicker](/assets/datepicker.png)
*   Dialog – виджет, предназначенный для создания слегка неуклюжих диалоговых окон:
  ![jQuery UI Dialog](/assets/dialog.png)
*   Menu – создание меню из списка, с поддержкой вложенности
*   Progressbar – название говорит само за себя, но в HTML 5 он тоже включён:
  ![jQuery UI ProgressBar](/assets/progressbar.png)
*   Slider – ещё один виджет для устаревших браузеров:
  ![jQuery UI Slider](/assets/slider.png)
*   Spinner – ещё один удобный контрол для форм, опять же, в HTML 5 уже есть:
  ![jQuery UI Spinner](/assets/spinner.png)
*   Tabs – они же табы, достаточно популярный элемент в web-разработке, и так же, как и «Accordion», вполне заменяем простым кодом (см. [tabs.html](http://anton.shevchuk.name/book/code/tabs.html)):
  ![jQuery UI Tabs](/assets/tabs.png)
*   Tooltip – вот и последний виджет, всплывающие подсказки; простой и должен быть востребован, ну а там жизнь покажет

На этом обзор виджетов можно считать законченным, вернёмся к плагинам.

> _Все виджеты и плагины завязаны на ядро jQuery UI, но есть также зависимости между самими плагинами и стоит о них помнить. Но не переживайте – при сборке jQuery UI пакета все зависимости проверяются автоматически, т.е. когда вам потребуется доселе неподключенный виджет, лучше скачать сборку заново._

### Утилиты

Утилит у нас не много – вот полезный плагин Position, который позволяет контролировать положение DOM-элементов – [http://jqueryui.com/position/](http://jqueryui.com/position/), а ещё есть фабрика по созданию виджетов, но о ней я расскажу чуть попозже.

### Эффекты

Среди эффектов, предоставляемых jQuery UI, я выделяю четыре пункта:

* Анимация цвета
* Анимация изменения классов
* Набор эффектов
* Расширение возможностей easing

За анимацию цвета отвечает компонент «Effects Core», который позволяет анимировать изменения цвета посредством использования функции «.animate()»:

```javascript
$("#my").animate({ backgroundColor: "black" }, 1000);
```

Да-да, базовый jQuery не умеет этого делать, а вот jQuery UI позволяет анимировать следующие параметры:

* `backgroundColor`
* `borderBottomColor`
* `borderLeftColor`
* `borderRightColor`
* `borderTopColor`
* `color`
* `outlineColor`

Ещё одной возможностью, заключенной в «Effects Core» является анимация изменений класса DOM-элемента, т.е. когда вы будете присваивать новый класс элементу, то вместо обычного моментального применения новых CSS свойств вы будете наблюдать анимацию этих свойств от текущих до заданных в присваиваемом классе. Для использования данного функционала нам потребуются старые знакомые – методы «.addClass()», «.toggleClass()» и «.removeClass()», с одной лишь разницей – при вызове метода вторым параметром должна быть указана скорость анимации:

```javascript
$("#my").addClass("active", 1000);

$("#my").toggleClass("active", 1000);

$("#my").removeClass("active", 1000);
```

Если из предыдущего абзаца у вас не возникло понимания сути происходящего, то этот код для вас:

```html
<style>
#my {
    font-size:14px;
}
#my.active {
    font-size:20px;
}
</style>
<script>
$(function () {
    $("#my").addClass("active", 1000);
    // тут получается аналогично следующему вызову
    $("#my").animate({"font-size":"20px"}, 1000);
});
</script>
```

> _А ещё появляется метод «.switchClass()», который заменяет один класс другим, но мне он ни разу не пригодился._

О наборе эффектов я не буду долго рассказывать, их лучше посмотреть в действии на странице [http://jqueryui.com/effect/](http://jqueryui.com/effect/). Для работы с эффектами появляется метод «.effect()», но сам по себе его лучше не использовать, ведь UI расширил функционал встроенных методов «.show()», «.hide()» и «.toggle()». Теперь, передав в качестве параметра скорости анимации названия эффекта, вы получите необходимый результат:

```javascript
$("#my").hide("puff");

$("#my").show("transfer");

$("#my").toggle("explode");
```

> _Приведу список эффектов, может, кто запомнит: `blind`, `bounce`, `clip`, `drop`, `explode`, `fold`, `highlight`, `puff`, `pulsate`, `scale`, `shake`, `size`, `slide`, `transfer`._

Помните, в главе об [анимации](40_animatsiya/README.md) я рассказывал об easing и одноименном плагине для jQuery? Так вот, UI тоже расширяет easing, так что подключив UI, можно отключать easing. И да, этот функционал завязан лишь на «Effects Core».

### Темы

Одной из самых замечательных особенностей jQuery UI является возможность менять «шкурки» всех виджетов разом, и для этого даже предусмотрена специальная утилита – [ThemeRoller](http://jqueryui.com/themeroller/):

![jQuery UI Theme Roller](/assets/theme-roller.png)

> _Если в какой-то момент времени потребуется внести изменения в тему, откройте файл «jquery-ui-#.#.##-custom.css» и найдите строчку начинающуюся с текста «To view and modify this theme, visit http:...». Пройдите по указанной ссылке и, используя ThemeRoller, внесите необходимые изменения._

### Пишем свой виджет

Отправной точкой при написании виджета для jQuery UI для вас будет [официальная документация](http://wiki.jqueryui.com/w/page/12138135/Widget%20factory), но поскольку со знанием английского не у всех сложилось, то я постараюсь перевести и адаптировать информацию, изложенную в ней.

Первое, о чём стоит рассказать, это то, что правила написания плагинов для jQuery слишком вальяжны, что не способствует их качеству. При создании jQuery UI, походу, решили пойти путём стандартизации процесса написания плагинов и виджетов. Я не могу сказать насколько задумка удалась, но стало явно лучше чем было. Начну с описания каркаса для вашего виджета:

```javascript
$.widget("book.expose", {
    // настройки по умолчанию
    options: {
        color: "red"
    },
    // инициализация widget
    // вносим изменения в DOM и вешаем обработчики
    _create: function() {
        this.element;    // искомый объект в jQuery-обёртке
        this.name;       // имя - expose
        this.namespace;  // пространство – book
        this.element.on("click."+this.eventNamespace, function(){
            console.log("click");
        });
    },
    // метод отвечает за применение настроек
    _setOption: function( key, value ) {
        // применяем изменения настроек
        this._super("_setOption", key, value );
    },
    // метод _destroy должен быть антиподом к _create
    // он должен убрать все изменения, внесенные в DOM, и убрать все обработчики, если таковые были
    _destroy: function() {
        this.element.off('.'+this.eventNamespace);
    }
});
```

Поясню для тех, кто не прочёл комментарии:

`options` – хранилище настроек виджета для конкретного элемента

`_create()` – отвечает за инициализацию виджета – тут в DOM должны происходить изменения и «вешаться» обработчики событий

`_destroy()` – антипод для «\_create()» – должен подчистить всё, что мы намусорили

`_setOption(key, value)` – данный метод будет вызван при попытке изменить какие-либо настройки:

```javascript
$("#my").expose({key:value})
```

> _Наблюдательный глаз заметит, что все перечисленные методы начинаются со знака подчёркивания – это такой способ выделить «приватные» методы, которые недоступны для запуска. Если мы попытаемся запустить «$('#my').expose('_destroy')», то получим ошибку. Но учтите – это лишь договорённость, соблюдайте, её!_

> _Для обхода договорённости о приватности можно использовать метод «data()»:_

```javascript
$("#my").data("expose")._destroy() // место для смайла «(evil)»
```

В данном примере я постарался задать хороший тон написания виджетов – я «повесил» обработчики событий в namespace. Это даст в дальнейшем возможность контролировать происходящее без необходимости залазить в код виджета. «True story».

> _Код, описанный в методе «\_destroy()», избыточен, т.к. он и так выполняется в публичном «destroy()». Приведён тут для наглядности._

А для ленивых, чтобы не прописывать каждый раз «eventNamespace» в обработчиках событий, разработчики добавили в версии 1.9.0 два метода: «\_on()» и «\_off()». Первый принимает два параметра:

*   DOM-элемент, или селектор, или jQuery-объект
*   набор обработчиков событий в виде объекта

Все перечисленные события будут «висеть» в пространстве «eventNamespace», т.е. результат будет предположительно одинаковым:

```javascript
this._on(this.element, {
    mouseover:function(event) {
        console.log("Hello mouse");
    },
    mouseout:function(event) {
        console.log("Bye mouse");
    }
});
```

Второй метод, «_off()», позволяет выборочно отключать обработчики:

```javascript
this._off(this.element, "mouseout click");
```

Ну, каркас баркасом, пора переходить к функционалу. Добавим произвольную функцию с произвольным функционалом:

```javascript
callMe:function() {
    console.log("Allo?");
}
```

К данной функции мы легко сможем обращаться как из других методов виджета, так и извне:

```javascript
// изнутри
this.callMe()
// извне
$("#my").expose("callMe")
```

Если ваша функция принимает параметры, то передача оных осуществляется следующим способом:

```javascript
$("#my").expose("callMe", "Hello!")
```

Если вы хотите достучаться в обработчике событий до метода виджета, то не забудьте про область видимости переменных и сделайте следующий манёвр:

```javascript
{
    _create: function() {
        var self = this; // вот он!
        this.element.on("click."+this.eventNamespace, function() {
            // тут используем self, т.к. this уже указывает на
            // элемент по которому кликаем
            self.callMe();
        })
    }
}
```

Хорошо идём, теперь поговорим о событиях. Для более гибкой разработки и внедрения виджетов предусмотрен функционал по созданию произвольных событий и их «прослушиванию»:

```javascript
// инициируем событие
this._trigger("incomingCall");

// подписываемся на событие при инициализации виджета
$("#my").expose({
    incommingCall: function(ev) {
        console.log("din-don");
    }
})

// или после, используя в качестве имени события
// имя виджета + имя события
$("#my").on("exposeincomingCall", function() {
    console.log("tru-lya-lya")
});
```

Материала много, я понимаю, но ещё добавлю описание нескольких методов, которые можно вызвать из самого виджета:

`_delay()` – данная функция работает как «setTimeout()», вот только контекст переданной функции будет указывать на сам виджет (это чтобы не заморачиваться с областью видимости)

`_hoverable()` и `_focusable()` – данным методам необходимо скармливать элементы, для которых необходимо отслеживать события «hover» и «focus», чтобы автоматически добавить к ним классы «ui-state-hover» и «ui-state-focus» при наступлении оных

`_hide()` и `_show()` – эти два метода появились в версии 1.9.0, они созданы дабы стандартизировать поведение виджетов при использовании методов анимации; настройки принято прятать в опциях под ключами «hide» и «show» соответственно. Использовать методы следует следующим образом:

```javascript
{
    options: {
        hide: {
            effect: "slideDown", // настройки эквиваленты вызову
            duration: 500        // .slideDown( 500)
        }
    }
}
// внутри виджета следует использовать вызовы _hide() и _show()
this._hide( this.element, this.options.hide, function() {
    // это наша функция обратного вызова
    console.log('спрятали');
});
```

Существует ещё пара методов, которые реализованы до нас:

```javascript
{
    enable: function() {
        return this._setOption( "disabled", false );
    },
    disable: function() {
        return this._setOption( "disabled", true );
    }
}
```

Фактически, данные функции создают синоним для вызова:

```javascript
$("#my").expose({ "disabled": true }) // или false
```

Наша задача сводится лишь к отслеживанию этого флага в методе «\_setOption()».

Примеру быть – [widget.html](http://anton.shevchuk.name/book/code/widget.html). Возможно, этот виджет и не будет популярен, зато он наглядно демонстрирует, как создавать виджеты для jQuery UI.

> _Будьте внимательны, с выходом jQuery UI версии 1.9.0 были внесены правки в Widget API, следовательно, большинство доступной информации устарело, так что читайте [официальную документацию](http://wiki.jqueryui.com/w/page/12138135/Widget%20factory). А ещё лучше – заглядывайте в код готовых виджетов «от производителя»._

Информация по теме разработки виджетов:
* [The jQuery UI Widget Factory. WAT?](http://ajpiano.com/widgetfactory/) – эта документации актуальна 
* [Understanding jQuery UI widgets: A tutorial](http://bililite.com/blog/understanding-jquery-ui-widgets-a-tutorial/)
* [Tips for Developing jQuery UI 1.8 Widgets](http://www.erichynds.com/jquery/tips-for-developing-jquery-ui-widgets/)
* [Coding your First jQuery UI Plugin](http://net.tutsplus.com/tutorials/javascript-ajax/coding-your-first-jquery-ui-plugin/)
